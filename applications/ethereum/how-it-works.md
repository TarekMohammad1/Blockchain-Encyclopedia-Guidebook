---
description: 'Source: https://www.preethikasireddy.com/post/how-does-ethereum-work-anyway'
---

# How it works

{% embed url="https://www.preethikasireddy.com/post/how-does-ethereum-work-anyway" %}

**Overview**

The Ethereum blockchain is essentially a transaction-based state machine. In computer science, a state machine refers to something that will read a series of inputs and, based on those inputs, will transition to a new state.

With Ethereum’s state machine, we begin with a “genesis state.” This is analogous to a blank slate, before any transactions have happened on the network. When transactions are executed, this genesis state transitions into some final state. At any point in time, this final state represents the current state of Ethereum.

<figure><img src="../../.gitbook/assets/image (21).png" alt=""><figcaption></figcaption></figure>

The state of Ethereum has millions of transactions. These transactions are grouped into “blocks.” A block contains a series of transactions, and each block is chained together with its previous block.

<figure><img src="../../.gitbook/assets/image (20).png" alt=""><figcaption></figcaption></figure>

For a block to be added to the main blockchain, the miner must prove it faster than any other competitor miner. The process of validating each block by having a miner provide a mathematical proof is known as a **“proof of work.”**

****

**Accounts**

The global “shared-state” of Ethereum is comprised of many small objects (“accounts”) that are able to interact with one another through a message-passing framework. Each account has a **state** associated with it and a 20-byte **address**. An address in Ethereum is a 160-bit identifier that is used to identify any account.

There are two types of accounts:

* Externally owned accounts, which are **controlled by private keys** and have **no code associated with them.**
* Contract accounts, which are **controlled by their contract code** and **have code associated with them.**

<figure><img src="../../.gitbook/assets/image (44).png" alt=""><figcaption></figcaption></figure>

#### Gas and payment

**Gas** is the unit used to measure the fees required for a particular computation. **Gas price** is the amount of Ether you are willing to spend on every unit of gas, and is measured in “gwei.” “Wei” is the smallest unit of Ether, where 1⁰¹⁸ Wei represents 1 Ether. One gwei is 1,000,000,000 Wei.

With every transaction, a sender sets a **gas limit** and **gas price**. The product of **gas price** and **gas limit** represents the maximum amount of Wei that the sender is willing to pay for executing a transaction.

For example, let’s say the sender sets the gas limit to 50,000 and a gas price to 20 gwei. This implies that the sender is willing to spend at most 50,000 x 20 gwei = 1,000,000,000,000,000 Wei = 0.001 Ether to execute that transaction.

<figure><img src="../../.gitbook/assets/image (11).png" alt=""><figcaption></figcaption></figure>

**There are fees for storage, too**

**Not only is gas used to pay for computation steps, it is also used to pay for storage usage.** The total fee for storage is proportional to the smallest multiple of 32 bytes used.

****

### Transaction and messages

We noted earlier that Ethereum is a **transaction-based state machine.** In other words, transactions occurring between different accounts are what move the global state of Ethereum from one state to the next.

**In the most basic sense, a transaction is a cryptographically signed piece of instruction that is generated by an externally owned account, serialized, and then submitted to the blockchain.**

There are two types of transactions: **message calls** and **contract creations** (i.e. transactions that create new Ethereum contracts).

**Contracts that exist within the global scope of Ethereum’s state can talk to other contracts within that same scope. The way they do this is via “messages” or “internal transactions” to other contracts.**

**When one contract sends an internal transaction to another contract, the associated code that exists on the recipient contract account is executed.**

<figure><img src="../../.gitbook/assets/image (28).png" alt=""><figcaption></figcaption></figure>

### Blocks

All transactions are grouped together into “blocks.” A blockchain contains a series of such blocks that are chained together.

In Ethereum, a block consists of:

* the **block header**
* information about the **set of transactions** included in that block
* a **set of other block headers for the current block’s ommers**.

****

### Transaction Execution



First, all transactions must meet an initial set of requirements in order to be executed. These include:

* The transaction must be a properly formatted **RLP**. “RLP” stands for “Recursive Length Prefix” and is a data format used to encode nested arrays of binary data. RLP is the format Ethereum uses to serialize objects.
* Valid transaction signature.
* Valid transaction nonce. Recall that the nonce of an account is the count of transactions sent from that account. To be valid, a transaction nonce must be equal to the sender account’s nonce.
* The transaction’s gas limit must be equal to or greater than the **intrinsic gas** used by the transaction. The intrinsic gas includes:
* 1\) a predefined cost of 21,000 gas for executing the transaction
* 2\) a gas fee for data sent with the transaction (4 gas for every byte of data or code that equals zero, and 68 gas for every non-zero byte of data or code)
* 3\) if the transaction is a contract-creating transaction, an additional 32,000 gas
* 4\) gas cost of each operation performed by transaction ([see Appendix G](https://ethereum.github.io/yellowpaper/paper.pdf))
* The sender’s account balance must have enough Ether to cover the **“upfront” gas costs** that the sender must pay. The calculation for the upfront gas cost is simple: First, the transaction’s **gas limit** is multiplied by the transaction’s **gas price** to determine the maximum gas cost. Then, this maximum cost is added to the total value being transferred from the sender to the recipient.

If the transaction meets all of the above requirements for validity, then we move onto the next step.

First, we deduct the upfront cost of execution from the sender’s balance, and increase the nonce of the sender’s account by 1 to account for the current transaction. At this point, we can calculate the gas remaining as the **total gas limit for the transaction minus the intrinsic gas used.**

Next, the transaction starts executing. Throughout the execution of a transaction, Ethereum keeps track of the “substate.” This substate is a way to record information accrued during the transaction that will be needed immediately after the transaction completes.

Once all the steps required by the transaction have been processed, and assuming there is no invalid state, the state is finalized by determining the amount of unused gas to be refunded to the sender. In addition to the unused gas, the sender is also refunded some allowance from the “refund balance” that we described above.

Once the sender is refunded:

* the Ether for the gas is given to the miner
* the gas used by the transaction is added to the block gas counter (which keeps track of the total gas used by all transactions in the block, and is useful when validating a block)
* all accounts in the self-destruct set (if any) are deleted

Finally, we’re left with the new state and a set of the logs created by the transaction.

****

### Execution model

**The part of the protocol that actually handles processing the transactions is Ethereum’s own virtual machine, known as the Ethereum Virtual Machine (EVM).**

The EVM is a Turing complete virtual machine, as defined earlier. The only limitation the EVM has that a typical Turing complete machine does not is that the EVM is intrinsically bound by gas. Thus, the total amount of computation that can be done is intrinsically limited by the amount of gas provided.

<figure><img src="../../.gitbook/assets/image (1).png" alt=""><figcaption></figcaption></figure>

Moreover, the EVM has a stack-based architecture. A [stack machine](https://en.wikipedia.org/wiki/Stack\_machine) is a computer that uses a last-in, first-out stack to hold temporary values.

The size of each stack item in the EVM is 256-bit, and the stack has a maximum size of 1024.

The EVM has memory, where items are stored as word-addressed byte arrays. Memory is volatile, meaning it is not permanent.

The EVM also has storage. Unlike memory, storage is non-volatile and is maintained as part of the system state. The EVM stores program code separately, in a virtual [ROM](https://en.wikipedia.org/wiki/Read-only\_memory) that can only be accessed via special instructions. In this way, the EVM differs from the typical [von Neumann architecture](https://en.wikipedia.org/wiki/Von\_Neumann\_architecture), in which program code is stored in memory or storage.

\








****

****

****
